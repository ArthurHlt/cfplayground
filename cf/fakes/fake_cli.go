// This file was generated by counterfeiter
package fakes

import (
	"sync"

	"github.com/simonleung8/cfplayground/cf"
	"github.com/simonleung8/cfplayground/websocket"
)

type FakeCLI struct {
	LoginStub        func() error
	loginMutex       sync.RWMutex
	loginArgsForCall []struct{}
	loginReturns     struct {
		result1 error
	}
	AppsStub        func() error
	appsMutex       sync.RWMutex
	appsArgsForCall []struct{}
	appsReturns     struct {
		result1 error
	}
	AppStub        func(string) error
	appMutex       sync.RWMutex
	appArgsForCall []struct {
		arg1 string
	}
	appReturns struct {
		result1 error
	}
	PushStub        func() error
	pushMutex       sync.RWMutex
	pushArgsForCall []struct{}
	pushReturns     struct {
		result1 error
	}
	DeleteStub        func(string) error
	deleteMutex       sync.RWMutex
	deleteArgsForCall []struct {
		arg1 string
	}
	deleteReturns struct {
		result1 error
	}
	OutputStub        func(websocket.Message)
	outputMutex       sync.RWMutex
	outputArgsForCall []struct {
		arg1 websocket.Message
	}
	EnvVarStub        func() string
	envVarMutex       sync.RWMutex
	envVarArgsForCall []struct{}
	envVarReturns     struct {
		result1 string
	}
	StatusStub        func() cf.StatusType
	statusMutex       sync.RWMutex
	statusArgsForCall []struct{}
	statusReturns     struct {
		result1 cf.StatusType
	}
}

func (fake *FakeCLI) Login() error {
	fake.loginMutex.Lock()
	defer fake.loginMutex.Unlock()
	fake.loginArgsForCall = append(fake.loginArgsForCall, struct{}{})
	if fake.LoginStub != nil {
		return fake.LoginStub()
	} else {
		return fake.loginReturns.result1
	}
}

func (fake *FakeCLI) LoginCallCount() int {
	fake.loginMutex.RLock()
	defer fake.loginMutex.RUnlock()
	return len(fake.loginArgsForCall)
}

func (fake *FakeCLI) LoginReturns(result1 error) {
	fake.LoginStub = nil
	fake.loginReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeCLI) Apps() error {
	fake.appsMutex.Lock()
	defer fake.appsMutex.Unlock()
	fake.appsArgsForCall = append(fake.appsArgsForCall, struct{}{})
	if fake.AppsStub != nil {
		return fake.AppsStub()
	} else {
		return fake.appsReturns.result1
	}
}

func (fake *FakeCLI) AppsCallCount() int {
	fake.appsMutex.RLock()
	defer fake.appsMutex.RUnlock()
	return len(fake.appsArgsForCall)
}

func (fake *FakeCLI) AppsReturns(result1 error) {
	fake.AppsStub = nil
	fake.appsReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeCLI) App(arg1 string) error {
	fake.appMutex.Lock()
	defer fake.appMutex.Unlock()
	fake.appArgsForCall = append(fake.appArgsForCall, struct {
		arg1 string
	}{arg1})
	if fake.AppStub != nil {
		return fake.AppStub(arg1)
	} else {
		return fake.appReturns.result1
	}
}

func (fake *FakeCLI) AppCallCount() int {
	fake.appMutex.RLock()
	defer fake.appMutex.RUnlock()
	return len(fake.appArgsForCall)
}

func (fake *FakeCLI) AppArgsForCall(i int) string {
	fake.appMutex.RLock()
	defer fake.appMutex.RUnlock()
	return fake.appArgsForCall[i].arg1
}

func (fake *FakeCLI) AppReturns(result1 error) {
	fake.AppStub = nil
	fake.appReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeCLI) Push() error {
	fake.pushMutex.Lock()
	defer fake.pushMutex.Unlock()
	fake.pushArgsForCall = append(fake.pushArgsForCall, struct{}{})
	if fake.PushStub != nil {
		return fake.PushStub()
	} else {
		return fake.pushReturns.result1
	}
}

func (fake *FakeCLI) PushCallCount() int {
	fake.pushMutex.RLock()
	defer fake.pushMutex.RUnlock()
	return len(fake.pushArgsForCall)
}

func (fake *FakeCLI) PushReturns(result1 error) {
	fake.PushStub = nil
	fake.pushReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeCLI) Delete(arg1 string) error {
	fake.deleteMutex.Lock()
	defer fake.deleteMutex.Unlock()
	fake.deleteArgsForCall = append(fake.deleteArgsForCall, struct {
		arg1 string
	}{arg1})
	if fake.DeleteStub != nil {
		return fake.DeleteStub(arg1)
	} else {
		return fake.deleteReturns.result1
	}
}

func (fake *FakeCLI) DeleteCallCount() int {
	fake.deleteMutex.RLock()
	defer fake.deleteMutex.RUnlock()
	return len(fake.deleteArgsForCall)
}

func (fake *FakeCLI) DeleteArgsForCall(i int) string {
	fake.deleteMutex.RLock()
	defer fake.deleteMutex.RUnlock()
	return fake.deleteArgsForCall[i].arg1
}

func (fake *FakeCLI) DeleteReturns(result1 error) {
	fake.DeleteStub = nil
	fake.deleteReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeCLI) Output(arg1 websocket.Message) {
	fake.outputMutex.Lock()
	defer fake.outputMutex.Unlock()
	fake.outputArgsForCall = append(fake.outputArgsForCall, struct {
		arg1 websocket.Message
	}{arg1})
	if fake.OutputStub != nil {
		fake.OutputStub(arg1)
	}
}

func (fake *FakeCLI) OutputCallCount() int {
	fake.outputMutex.RLock()
	defer fake.outputMutex.RUnlock()
	return len(fake.outputArgsForCall)
}

func (fake *FakeCLI) OutputArgsForCall(i int) websocket.Message {
	fake.outputMutex.RLock()
	defer fake.outputMutex.RUnlock()
	return fake.outputArgsForCall[i].arg1
}

func (fake *FakeCLI) EnvVar() string {
	fake.envVarMutex.Lock()
	defer fake.envVarMutex.Unlock()
	fake.envVarArgsForCall = append(fake.envVarArgsForCall, struct{}{})
	if fake.EnvVarStub != nil {
		return fake.EnvVarStub()
	} else {
		return fake.envVarReturns.result1
	}
}

func (fake *FakeCLI) EnvVarCallCount() int {
	fake.envVarMutex.RLock()
	defer fake.envVarMutex.RUnlock()
	return len(fake.envVarArgsForCall)
}

func (fake *FakeCLI) EnvVarReturns(result1 string) {
	fake.EnvVarStub = nil
	fake.envVarReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeCLI) Status() cf.StatusType {
	fake.statusMutex.Lock()
	defer fake.statusMutex.Unlock()
	fake.statusArgsForCall = append(fake.statusArgsForCall, struct{}{})
	if fake.StatusStub != nil {
		return fake.StatusStub()
	} else {
		return fake.statusReturns.result1
	}
}

func (fake *FakeCLI) StatusCallCount() int {
	fake.statusMutex.RLock()
	defer fake.statusMutex.RUnlock()
	return len(fake.statusArgsForCall)
}

func (fake *FakeCLI) StatusReturns(result1 cf.StatusType) {
	fake.StatusStub = nil
	fake.statusReturns = struct {
		result1 cf.StatusType
	}{result1}
}

var _ cf.CLI = new(FakeCLI)
